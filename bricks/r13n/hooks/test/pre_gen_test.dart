import 'dart:io';

import 'package:mason/mason.dart';
import 'package:mocktail/mocktail.dart';
import 'package:path/path.dart' as path;
import 'package:r13n_hooks/hooks.dart';
import 'package:test/test.dart';

import '../pre_gen.dart' as pre_gen;

class _MockHookContext extends Mock implements HookContext {}

class _MockLogger extends Mock implements Logger {}

class _MockFile extends Mock implements File {}

class _MockDirectory extends Mock implements Directory {}

class _MockFileSystemEntity extends Mock implements FileSystemEntity {}

void main() {
  group('pre_gen', () {
    late HookContext hookContext;
    late Logger logger;
    late File configFile;
    late Directory arbDir;
    late File arbFile;

    setUp(() {
      configFile = _MockFile();
      const configFileContent = '''
arb-dir: ARB_DIR
template-arb-file: TEMPLATE_ARB_FILE
''';
      when(() => configFile.readAsString()).thenAnswer(
        (_) async => configFileContent,
      );
      when(() => configFile.existsSync()).thenReturn(true);
      arbDir = _MockDirectory();

      final fileSystemEntity = _MockFileSystemEntity();
      when(() => fileSystemEntity.path).thenReturn('app_us.arb');
      when(() => arbDir.listSync()).thenReturn([fileSystemEntity]);

      arbFile = _MockFile();
      const arbFileContent = '''
{
    "@@region": "us",
    "aValue": "A Value"
}
''';
      when(() => arbFile.readAsString()).thenAnswer(
        (_) async => arbFileContent,
      );
      when(() => arbFile.existsSync()).thenReturn(true);

      logger = _MockLogger();
      hookContext = _MockHookContext();
      when(() => hookContext.logger).thenReturn(logger);
    });

    test('returns normally', () async {
      var vars = <String, dynamic>{};

      when(() => hookContext.vars = any()).thenAnswer((invocation) {
        if (invocation.isGetter) return vars;
        return vars =
            invocation.positionalArguments.first as Map<String, dynamic>;
      });

      await IOOverrides.runZoned(
        createDirectory: (path) => arbDir,
        createFile: (path) {
          if (path.endsWith('r13n.yaml')) {
            return configFile;
          } else if (path.endsWith('app_us.arb')) {
            return arbFile;
          } else {
            throw UnsupportedError('Unexpected path: $path');
          }
        },
        () async {
          await pre_gen.preGen(hookContext, ensureRuntimeCompatibility: (_) {});

          expect(
            vars,
            equals({
              'regions': [
                {
                  'code': 'us',
                  'values': [
                    {'key': 'aValue', 'value': 'A Value'},
                  ],
                }
              ],
              'getters': [
                {'value': 'aValue'},
              ],
              'fallbackCode': 'us',
              'arbDir': 'ARB_DIR',
            }),
          );
        },
      );
    });

    test('exits when an R13nCompatibilityException occurs', () async {
      final cwd = Directory.current;
      final tempDir = Directory.systemTemp.createTempSync();
      Directory.current = tempDir;
      File(path.join(tempDir.path, 'pubspec.lock')).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  not_r13n:
    dependency: "direct main"
    source: hosted
    version: "0.1.0"
sdks:
  dart: ">=2.18.0 <3.0.0"
''');
      final exitCalls = <int>[];
      await pre_gen.preGen(hookContext, exit: exitCalls.add);
      expect(exitCalls, equals([1]));
      Directory.current = cwd;
      tempDir.delete(recursive: true).ignore();
    });

    test('when it fails, throws a R13nException', () async {
      final cwd = Directory.current;
      final tempDir = Directory.systemTemp.createTempSync();
      Directory.current = tempDir;
      File(path.join(tempDir.path, 'pubspec.lock')).writeAsStringSync('''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  r13n:
    dependency: "direct main"
    source: hosted
    version: "0.1.0-dev.2"
sdks:
  dart: ">=2.18.0 <3.0.0"
''');
      final exitCalls = <int>[];
      try {
        await pre_gen.preGen(hookContext, exit: exitCalls.add);
      } on Exception catch (err) {
        expect(err, isA<R13nException>());
      }
      expect(exitCalls, equals([]));
      Directory.current = cwd;
      tempDir.delete(recursive: true).ignore();
    });
  });
}
